{
    "sourceFile": "src/app/api/tasks/route.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1762632803223,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762633819019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,10 +47,16 @@\n     const parsed = TaskCreateSchema.safeParse(json);\r\n     if (!parsed.success) {\r\n       return new Response(JSON.stringify({ message: 'Validation error', errors: parsed.error.flatten() }), { status: 400 });\r\n     }\r\n-    const { title, dueAt } = parsed.data;\r\n-    const task = await Task.create({ user: user._id, title, dueAt: dueAt ? new Date(dueAt) : undefined });\r\n+    const { title, description, dueAt } = parsed.data;\r\n+    const task = await Task.create({ \r\n+      user: user._id, \r\n+      userId: user._id.toString(), \r\n+      title, \r\n+      description: description || '',\r\n+      dueAt: dueAt ? new Date(dueAt) : undefined \r\n+    });\r\n     // Notify user about new task\r\n     try {\r\n       await sendPushToUser(user._id, {\r\n         title: 'Task created ✅',\r\n"
                },
                {
                    "date": 1762633828476,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,76 @@\n+import Task from '@/models/Task';\r\n+import { rateLimit } from '@/lib/rateLimiter';\r\n+import { getUserFromRequest } from '@/lib/auth';\r\n+import { TaskCreateSchema } from '@/features/tasks/schemas';\r\n+import { sendPushToUser } from '@/lib/push';\r\n+\r\n+export async function GET(req) {\r\n+  try {\r\n+    const ip = req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip') || 'unknown';\r\n+    const rl = rateLimit(`tasks:list:${ip}`, 30, 60 * 1000);\r\n+    if (!rl.ok) return new Response(JSON.stringify({ message: 'Too many requests' }), { status: 429 });\r\n+\r\n+    const { user } = await getUserFromRequest(req);\r\n+  const tasks = await Task.find({ userId: user._id.toString() }).sort({ dueAt: 1, createdAt: -1 }).lean();\r\n+  \r\n+  // Format tasks to ensure _id is string and all fields are properly serialized\r\n+  const formattedTasks = tasks.map(task => ({\r\n+    ...task,\r\n+    _id: task._id.toString(),\r\n+    user: task.user?.toString(),\r\n+    dueAt: task.dueAt ? task.dueAt.toISOString() : null,\r\n+    dueDate: task.dueDate ? task.dueDate.toISOString() : null,\r\n+    completedAt: task.completedAt ? task.completedAt.toISOString() : null,\r\n+    createdAt: task.createdAt ? task.createdAt.toISOString() : null,\r\n+    updatedAt: task.updatedAt ? task.updatedAt.toISOString() : null\r\n+  }));\r\n+  \r\n+  console.log('Tasks GET - returning tasks count:', formattedTasks.length);\r\n+  return new Response(JSON.stringify({ tasks: formattedTasks }), { status: 200 });\r\n+  } catch (err) {\r\n+    if (err.message === 'NO_TOKEN' || err.message === 'INVALID_TOKEN') {\r\n+      return new Response(JSON.stringify({ message: 'Unauthorized' }), { status: 401 });\r\n+    }\r\n+    console.error(err);\r\n+    return new Response(JSON.stringify({ message: 'Server error' }), { status: 500 });\r\n+  }\r\n+}\r\n+\r\n+export async function POST(req) {\r\n+  try {\r\n+    const ip = req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip') || 'unknown';\r\n+    const rl = rateLimit(`tasks:create:${ip}`, 30, 60 * 1000);\r\n+    if (!rl.ok) return new Response(JSON.stringify({ message: 'Too many requests' }), { status: 429 });\r\n+\r\n+    const { user } = await getUserFromRequest(req);\r\n+    const json = await req.json();\r\n+    const parsed = TaskCreateSchema.safeParse(json);\r\n+    if (!parsed.success) {\r\n+      return new Response(JSON.stringify({ message: 'Validation error', errors: parsed.error.flatten() }), { status: 400 });\r\n+    }\r\n+    const { title, description, dueAt } = parsed.data;\r\n+    const task = await Task.create({ \r\n+      user: user._id, \r\n+      userId: user._id.toString(), \r\n+      title, \r\n+      description: description || '',\r\n+      dueAt: dueAt ? new Date(dueAt) : undefined \r\n+    });\r\n+    // Notify user about new task\r\n+    try {\r\n+      await sendPushToUser(user._id, {\r\n+        title: 'Task created ✅',\r\n+        body: `\"${title}\" was added${dueAt ? ` • due ${new Date(dueAt).toLocaleDateString()}` : ''}.`,\r\n+        icon: '/globe.svg',\r\n+        url: '/dashboard/tasks',\r\n+      });\r\n+    } catch {}\r\n+    return new Response(JSON.stringify({ task }), { status: 201 });\r\n+  } catch (err) {\r\n+    if (err.message === 'NO_TOKEN' || err.message === 'INVALID_TOKEN') {\r\n+      return new Response(JSON.stringify({ message: 'Unauthorized' }), { status: 401 });\r\n+    }\r\n+    console.error(err);\r\n+    return new Response(JSON.stringify({ message: 'Server error' }), { status: 500 });\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1762634563708,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,18 +13,27 @@\n     const { user } = await getUserFromRequest(req);\r\n   const tasks = await Task.find({ userId: user._id.toString() }).sort({ dueAt: 1, createdAt: -1 }).lean();\r\n   \r\n   // Format tasks to ensure _id is string and all fields are properly serialized\r\n-  const formattedTasks = tasks.map(task => ({\r\n-    ...task,\r\n-    _id: task._id.toString(),\r\n-    user: task.user?.toString(),\r\n-    dueAt: task.dueAt ? task.dueAt.toISOString() : null,\r\n-    dueDate: task.dueDate ? task.dueDate.toISOString() : null,\r\n-    completedAt: task.completedAt ? task.completedAt.toISOString() : null,\r\n-    createdAt: task.createdAt ? task.createdAt.toISOString() : null,\r\n-    updatedAt: task.updatedAt ? task.updatedAt.toISOString() : null\r\n-  }));\r\n+  const formattedTasks = tasks.map(task => {\r\n+    // Normalize status field for backwards compatibility\r\n+    let status = task.status || 'pending';\r\n+    if (!task.status && task.completed) {\r\n+      status = 'completed';\r\n+    }\r\n+    \r\n+    return {\r\n+      ...task,\r\n+      _id: task._id.toString(),\r\n+      user: task.user?.toString(),\r\n+      status: status, // Ensure status is always present\r\n+      dueAt: task.dueAt ? task.dueAt.toISOString() : null,\r\n+      dueDate: task.dueDate ? task.dueDate.toISOString() : null,\r\n+      completedAt: task.completedAt ? task.completedAt.toISOString() : null,\r\n+      createdAt: task.createdAt ? task.createdAt.toISOString() : null,\r\n+      updatedAt: task.updatedAt ? task.updatedAt.toISOString() : null\r\n+    };\r\n+  });\r\n   \r\n   console.log('Tasks GET - returning tasks count:', formattedTasks.length);\r\n   return new Response(JSON.stringify({ tasks: formattedTasks }), { status: 200 });\r\n   } catch (err) {\r\n"
                }
            ],
            "date": 1762632803223,
            "name": "Commit-0",
            "content": "import Task from '@/models/Task';\r\nimport { rateLimit } from '@/lib/rateLimiter';\r\nimport { getUserFromRequest } from '@/lib/auth';\r\nimport { TaskCreateSchema } from '@/features/tasks/schemas';\r\nimport { sendPushToUser } from '@/lib/push';\r\n\r\nexport async function GET(req) {\r\n  try {\r\n    const ip = req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip') || 'unknown';\r\n    const rl = rateLimit(`tasks:list:${ip}`, 30, 60 * 1000);\r\n    if (!rl.ok) return new Response(JSON.stringify({ message: 'Too many requests' }), { status: 429 });\r\n\r\n    const { user } = await getUserFromRequest(req);\r\n  const tasks = await Task.find({ user: user._id }).sort({ dueAt: 1, createdAt: -1 }).lean();\r\n  \r\n  // Format tasks to ensure _id is string and all fields are properly serialized\r\n  const formattedTasks = tasks.map(task => ({\r\n    ...task,\r\n    _id: task._id.toString(),\r\n    user: task.user?.toString(),\r\n    dueAt: task.dueAt ? task.dueAt.toISOString() : null,\r\n    dueDate: task.dueDate ? task.dueDate.toISOString() : null,\r\n    completedAt: task.completedAt ? task.completedAt.toISOString() : null,\r\n    createdAt: task.createdAt ? task.createdAt.toISOString() : null,\r\n    updatedAt: task.updatedAt ? task.updatedAt.toISOString() : null\r\n  }));\r\n  \r\n  console.log('Tasks GET - returning tasks count:', formattedTasks.length);\r\n  return new Response(JSON.stringify({ tasks: formattedTasks }), { status: 200 });\r\n  } catch (err) {\r\n    if (err.message === 'NO_TOKEN' || err.message === 'INVALID_TOKEN') {\r\n      return new Response(JSON.stringify({ message: 'Unauthorized' }), { status: 401 });\r\n    }\r\n    console.error(err);\r\n    return new Response(JSON.stringify({ message: 'Server error' }), { status: 500 });\r\n  }\r\n}\r\n\r\nexport async function POST(req) {\r\n  try {\r\n    const ip = req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip') || 'unknown';\r\n    const rl = rateLimit(`tasks:create:${ip}`, 30, 60 * 1000);\r\n    if (!rl.ok) return new Response(JSON.stringify({ message: 'Too many requests' }), { status: 429 });\r\n\r\n    const { user } = await getUserFromRequest(req);\r\n    const json = await req.json();\r\n    const parsed = TaskCreateSchema.safeParse(json);\r\n    if (!parsed.success) {\r\n      return new Response(JSON.stringify({ message: 'Validation error', errors: parsed.error.flatten() }), { status: 400 });\r\n    }\r\n    const { title, dueAt } = parsed.data;\r\n    const task = await Task.create({ user: user._id, title, dueAt: dueAt ? new Date(dueAt) : undefined });\r\n    // Notify user about new task\r\n    try {\r\n      await sendPushToUser(user._id, {\r\n        title: 'Task created ✅',\r\n        body: `\"${title}\" was added${dueAt ? ` • due ${new Date(dueAt).toLocaleDateString()}` : ''}.`,\r\n        icon: '/globe.svg',\r\n        url: '/dashboard/tasks',\r\n      });\r\n    } catch {}\r\n    return new Response(JSON.stringify({ task }), { status: 201 });\r\n  } catch (err) {\r\n    if (err.message === 'NO_TOKEN' || err.message === 'INVALID_TOKEN') {\r\n      return new Response(JSON.stringify({ message: 'Unauthorized' }), { status: 401 });\r\n    }\r\n    console.error(err);\r\n    return new Response(JSON.stringify({ message: 'Server error' }), { status: 500 });\r\n  }\r\n}\r\n"
        }
    ]
}